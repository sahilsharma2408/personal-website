---
title: "Getting Started with React Router v7"
date: "2024-12-15"
description: "React Router v7 brings a new era of full-stack React development with file-based routing, server-side rendering, and seamless data loading."
tags: ["React", "React Router", "TypeScript"]
readTime: "8 min read"
published: true
---

React Router v7 represents a significant evolution in how we build React applications. If you've been using React Router v6 or Remix, you'll find that v7 merges the best ideas from both projects into a single, cohesive framework. Let's explore what's changed and how to get started.

## What Changed from v6

The biggest shift in React Router v7 is its transformation from a client-side routing library into a full-stack framework. While v6 focused purely on client-side navigation, v7 absorbs the Remix framework's server-side capabilities. This means you get server-side rendering, data loading, form handling, and progressive enhancement out of the box.

The Remix team joined forces with React Router, and the result is that Remix as a separate package is no longer needed. Everything lives under the `react-router` umbrella now.

## File-Based Routing with routes.ts

One of the most practical changes is how you define routes. Instead of scattering route definitions across component trees, v7 uses a centralized `routes.ts` file:

```ts
import { type RouteConfig, index, route } from "@react-router/dev/routes";

export default [
  index("routes/_index.tsx"),
  route("about", "routes/about.tsx"),
  route("blog", "routes/blog._index.tsx"),
  route("blog/:slug", "routes/blog.$slug.tsx"),
] satisfies RouteConfig;
```

This gives you a single source of truth for your entire routing structure. You can see every route at a glance, control nesting explicitly, and TypeScript ensures your route configuration is valid.

## Loader Functions: Data Loading Done Right

Loaders are functions that run on the server before your component renders. They fetch data, check authentication, and prepare everything your component needs:

```tsx
export async function loader({ params }: Route.LoaderArgs) {
  const post = await getPost(params.slug);
  if (!post) throw data(null, { status: 404 });
  return { post };
}

export default function BlogPost() {
  const { post } = useLoaderData<typeof loader>();
  return <article>{post.title}</article>;
}
```

The beauty of this pattern is that your component never deals with loading states for initial data. The loader runs first, and the component receives the data as props. TypeScript infers the return type automatically, so you get full type safety from loader to component.

## Action Functions: Handling Mutations

Actions handle form submissions and other mutations. They run on the server when a form is submitted, and React Router handles the entire request-response cycle:

```tsx
export async function action({ request }: Route.ActionArgs) {
  const formData = await request.formData();
  const email = formData.get("email");
  await subscribeToNewsletter(email);
  return { success: true };
}
```

Combined with the `<Form>` component, actions give you progressive enhancement for free. Forms work even before JavaScript loads, and once it does, submissions happen without full-page reloads.

## TypeScript Integration

React Router v7 generates route-specific types automatically. When you run the dev server, it creates a `.react-router/types` directory with type definitions for each route. This means `loader`, `action`, and component props are all fully typed based on your actual route parameters.

The `Route.LoaderArgs` and `Route.ActionArgs` types know exactly which URL parameters your route has, eliminating an entire class of runtime errors.

## Setting Up with Vite

React Router v7 uses Vite as its build tool. A minimal setup looks like this:

```ts
import { reactRouter } from "@react-router/dev/vite";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [reactRouter()],
});
```

Vite's fast HMR, plugin ecosystem, and build optimizations make the development experience excellent. You can add MDX support, Tailwind CSS, and other tools through Vite plugins.

## Getting Started

The fastest way to start a new project is with the create command:

```bash
pnpm create react-router@latest my-app
```

This scaffolds a project with sensible defaults, TypeScript configured, and a working dev server. From there, you define routes, write loaders, and build your UI with the confidence that the framework handles SSR, code splitting, and data management for you.

React Router v7 is a mature, well-thought-out framework that makes full-stack React development feel natural. Whether you're building a simple blog or a complex application, it provides the right abstractions at every level.
